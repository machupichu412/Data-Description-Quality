[
  {
    "reverse_engineered_description": "This Attribute has a value of <3001> determined by commercial business.",
    "comment": "Specify that the value is static and clarify how it is uploaded (flat file).",
    "final_description": "This Attribute has a static value - <3001> decided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "Direct mapping to ARRType column from a provided source.",
    "comment": "Clarify that the source is a static file and mention that values are provided by commercial business.",
    "final_description": "Direct mapping to ARRType column coming from static file having string values provided by commercial business."
  },
  {
    "reverse_engineered_description": "Direct mapping to ServiceName column from a provided source.",
    "comment": "Clarify that the source is a static file and mention that values are provided by commercial business.",
    "final_description": "Direct mapping to ServiceName column coming from static file having string values provided by commercial business."
  },
  {
    "reverse_engineered_description": "Direct mapping to ServicePackageSKU column from a provided source.",
    "comment": "Clarify that the source is a static file and mention that values are provided by commercial business.",
    "final_description": "Direct mapping to ServicePackageSKU column coming from static file having string values provided by commercial business."
  },
  {
    "reverse_engineered_description": "This Attribute has values (2001,2002,2003,2004,2005) determined by commercial business.",
    "comment": "Specify that the values are static and clarify how they are uploaded (flat file).",
    "final_description": "This Attribute has a static value (2001,2002,2003,2004,2005) provided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "Direct mapping to ARRType column from a provided source.",
    "comment": "Clarify that the source is a static file and mention that values are provided by commercial business.",
    "final_description": "Direct mapping to ARRType column coming from static file having string values provided by commercial business."
  },
  {
    "reverse_engineered_description": "Direct mapping to ServicePackageName column from a provided source.",
    "comment": "Clarify that the source is a static file and mention that values are provided by commercial business.",
    "final_description": "Direct mapping to ServicePackageName column coming from static file having string values provided by commercial business."
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify unique records of DimCauseType table.",
    "comment": "Specify which column(s) are used for surrogate key generation and add the source table and source name.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimCauseType table. Generated based on the column CauseType."
  },
  {
    "reverse_engineered_description": "The attribute has values like >= 7Days <14Days, < 5hrs, >= Day <3Days, >= 21Days <31Days, Unknown, determined by commercial business.",
    "comment": "Confirm whether these values are static or hardcoded. If static, specify that they come from a static file provided by the business.",
    "final_description": "The attribute has static values of >= 7Days <14Days, < 5hrs, >= Day <3Days, >= 21Days <31Days, Unknown, decided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "The attribute has values like >= 7Days <14Days, <1Day, >= 21Days <31Days, >= 1Day <3Days, Unknown, determined by commercial business.",
    "comment": "Refer to row #15 where the attribute is IdleTimeL1 and entity is vwdimidletimespan for consistency.",
    "final_description": "The attribute has static values of >= 7Days <14Days, <1Day, >= 21Days <31Days, >= 1Day <3Days, Unknown, decided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in DimIdleTimeSpan table.",
    "comment": "Clarify the logic for surrogate key generation, specifying which columns contribute to it.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimIdleTimeSpan table.\nWhen IdleTimeL1 & IdleTimeL2 = \"Unknown\" and Sort=0 then hardcoded as -1\nWhen IdleTimeL1 ='< 5hrs' & IdleTimeL2 = '<1Day' and Sort=1 then hardcoded as 1\nWhen IdleTimeL1 ='>= 5hrs <8hrs' & IdleTimeL2 = '<1Day' and Sort=1 then hardcoded as 2\nWhen IdleTimeL1 ='>= 8hrs <16hrs' & IdleTimeL2 = '<1Day' and Sort=1 then hardcoded as 3\nWhen IdleTimeL1 ='>= 16hrs <1Day' & IdleTimeL2 = '<1Day' and Sort=1 then hardcoded as 4\nand goes on until it's hardcoded as 10."
  },
  {
    "reverse_engineered_description": "This attribute has values (0,1,2,3,4) determined by commercial business.",
    "comment": "Ensure consistency by referencing row #15, where IdleTimeL1 is described in the vwdimidletimespan entity.",
    "final_description": "This attribute has static values of (0,1,2,3,4) provided by Commercial Business.\nWhen IdleTimeL1 & IdleTimeL2 = \"Unknown\" then hardcoded as 0\nWhen IdleTimeL1 ='< 5hrs' & IdleTimeL2 = '<1Day' then hardcoded as 1\nWhen IdleTimeL1 ='>= Day <3Days' & IdleTimeL2 = '>= 1Day <3Days' then hardcoded as 2\nWhen IdleTimeL1 & IdleTimeL2 = '>= 3 Days <7Days' then hardcoded as 3\nWhen IdleTimeL1 & IdleTimeL2 = '>= 7Days <14Days' then hardcoded as 4"
  },
  {
    "reverse_engineered_description": "This attribute has values (Low, Unknown, Medium, High, Missed).",
    "comment": "Ensure consistency by referencing row #15, where IdleTimeL1 is described in the vwdimidletimespan entity.",
    "final_description": "This attribute has static values of (Low, Unknown, Medium, High, Missed) decided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in DimIRStatus table.",
    "comment": "Clarify the logic for surrogate key generation, specifying which columns contribute to it.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimIRStatus table.\nLogic: When IRStatus = \"Unknown\" then hardcoded as -1\nwhen IRStatus = \"Critical\" then hardcoded as 1\nwhen IRStatus = \"Hi\" then hardcoded as 2\nwhen IRStatus = \"Medium\" then hardcoded as 3\nwhen IRStatus = \"Low\" then hardcoded as 4\nwhen IRStatus = \"Met\" then hardcoded as 5\nwhen IRStatus = \"Missed\" then hardcoded as 6"
  },
  {
    "reverse_engineered_description": "This attribute has values (Complete, Unknown, Cancelled, Missed, Pending).",
    "comment": "Ensure consistency by referencing row #15, where IdleTimeL1 is described in the vwdimidletimespan entity.",
    "final_description": "This attribute has static values of (Complete ,Unknown ,Cancelled, Missed, Pending) decided by commercial business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in dimkpistate table.",
    "comment": "Clarify the logic for surrogate key generation, specifying the conditions under which values are hardcoded as 1 or 2.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of dimkpistate table.\nLogic: When KPIState = \"Unknown\" then hardcoded as -1\nwhen KPIState = \"Cancelled\" then hardcoded as 1\nwhen KPIState = \"Missed\" then hardcoded as 2\nwhen KPIState = \"Pending\" then hardcoded as 3\nwhen KPIState = \"Complete\" then hardcoded as 4"
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in DimLaborTimeSpan table.",
    "comment": "Clarify the logic for surrogate key generation, specifying which columns are involved and under what conditions values are hardcoded.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimLaborTimeSpan table.\nWhen LaborSpanL1 & LaborSpanL2 = \"Unknown\" and SortL1 & SortL2 = 0 then hardcoded as -1\nWhen LaborSpanL1=\"<100\", LaborSpanL2 = \"<50\" and SortL1 & SortL2 = 1 then hardcoded as 1\nWhen LaborSpanL1=\"<100\", LaborSpanL2 = \"<75\" and SortL1 = 2 & SortL2 = 1 then hardcoded as 2\nWhen LaborSpanL1=\"<100\", LaborSpanL2 = \"<100\" and SortL1 = 3 SortL2 = 1 then hardcoded as 3\nWhen LaborSpanL1=\"<200\", LaborSpanL2 = \"<150\" and SortL1 = 4 SortL2 = 2 then hardcoded as 4\nand goes so on until it's hardcoded as 20"
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in DimPhase table.",
    "comment": "Clarify the logic for surrogate key generation by specifying which columns contribute and include the source table and source name.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimPhase table. It is generated based on StateAnnotation column."
  },
  {
    "reverse_engineered_description": "This attribute has values (Unknown, <1 Hour, 1-3 Hours, etc.).",
    "comment": "Ensure consistency by referencing row #15, where IdleTimeL1 is described in the vwdimidletimespan entity.",
    "final_description": "This attribute has static values of (Unknown,<1 Hour,1-3 Hours etc) provided by the commercial business."
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to identify records in DimScopeAgeSpan table.",
    "comment": "Clarify the logic for surrogate key generation, specifying which columns contribute and ensuring consistency with referenced row #27.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimScopeAgeSpan table.\nLogic: When ScopeAgeSpan = \"Unknown\" then hardcoded as -1\nwhen ScopeAgeSpan = \"<1 Hour\" then hardcoded as 1\nwhen ScopeAgeSpan = \"1-3 Hours\" then hardcoded as 2\nwhen ScopeAgeSpan = \"3-7 Hours\" then hardcoded as 3\nwhen ScopeAgeSpan = \"7-10 Hours\" then hardcoded as 4\nwhen ScopeAgeSpan = \"10-15 Hours\" then hardcoded as 5\nwhen ScopeAgeSpan = \"15-20 Hours\" then hardcoded as 6\nwhen ScopeAgeSpan = \"20-24 Hours\" then hardcoded as 7\nwhen ScopeAgeSpan = \"> 24 hours\" then hardcoded as 8"
  },
  {
    "reverse_engineered_description": "Derived by applying decode logic on FullDate and IsWeekday columns of DimTime table.\nLogic: If FullDate is less than or equal to the current timestamp and IsWeekday is equal to 1, then it is hardcoded as 1, else hardcoded as 0.",
    "comment": "Add the source table name to clarify the data origin.",
    "final_description": "Derived by applying decode logic on FullDate and IsWeekday columns of DimTime table coming from Commercial NextDay Datamart within SA&DP source having integer values.\nLogic: If FullDate is less than or equal to the current timestamp and IsWeekday is equal to 1 then it hardcoded 1 else hardcoded as 0."
  },
  {
    "reverse_engineered_description": "Derived by applying Day logic on FullDate column in DimTime table.\nLogic: Extract the Day (Monday, ...) from the date value in FullDate.",
    "comment": "Use 'Commercial NextDay Datamart within SA&DP' instead of 'ND' for clarity.",
    "final_description": "Derived by applying Day logic on Fulldate columns coming in DimTime table coming from Commercial NextDay Datamart within SA&DP Datamart within SA&DP.\nLogic: Extract the Day (Monday, ...) from the date value coming in Fulldate."
  },
  {
    "reverse_engineered_description": "Derived by applying decode logic on DayName column in DimTime table.\nLogic: WHEN DayName = 'saturday' THEN hardcoded as 1, WHEN DayName = 'sunday' THEN hardcoded as 2, ... ELSE -1 END AS DayId.",
    "comment": "Use 'Commercial NextDay Datamart within SA&DP' instead of 'ND' for clarity.",
    "final_description": "Derived by applying decode logic on DayName column in DimTime table coming from Commercial NextDay Datamart within SA&DP Datamart within SA&DP.\nLogic: WHEN DayName = 'saturday' THEN hardcoded as 1   WHEN DayName = 'sunday' THEN hardcoded as 2\nWHEN DayName = 'monday'  THEN hardcoded as 3  WHEN DayName = 'tuesday'  THEN hardcoded as 4\nWHEN DayName = 'wednesday'  THEN hardcoded as 5  WHEN DayName = 'thursday' THEN hardcoded as 6\nWHEN DayName = 'friday'  THEN hardcoded as 7 ELSE - 1  END AS DayId"
  },
  {
    "reverse_engineered_description": "Direct mapping to DayName column in DimTime table.",
    "comment": "Remove extra wording in the description.",
    "final_description": "Direct mapping to DayName in DimTime table coming from Commercial NextDay Datamart within SA&DP Datamart within SA&DP having string values."
  },
  {
    "reverse_engineered_description": "Derived by applying decode logic on FiscalWeek and FiscalYear columns from DimTime table.\nLogic: CASE WHEN Length(FiscalWeek) = 1 THEN CONCAT(FiscalYear, 0, FiscalWeek)\nELSE CONCAT(FiscalYear, FiscalWeek) END AS FiscalCumulativeWeek.",
    "comment": "Format the logic properly as shown for better readability.",
    "final_description": "Derived by applying decode logic on FiscalWeek and FiscalYear columns coming from DimTime table coming from Commercial NextDay Datamart within SA&DP source.\nLogic: CASE WHEN Length(FiscalWeek) = 1 THEN Cast(CONCAT ( FiscalYear ,0,FiscalWeek) AS INT)\nELSE Cast(CONCAT ( FiscalYear ,FiscalWeek ) AS INT) END AS FiscalCumulativeWeek"
  },
  {
    "reverse_engineered_description": "Direct mapping to FiscalQuarter column in DimTime table.",
    "comment": "Phrase the description properly. Clearly mention the month range for each value (e.g., Value 1 corresponds to July–September).",
    "final_description": "Direct mapping to FiscalQuarter column in DimTime table coming from Commercial NextDay Datamart within SA&DP having integer values.\n(Ex: For FiscalPeriod Value as 1 (July–September) then FiscalQuarter is populated as - 2007-07-01T00:00:00.000+0000,\nFor FiscalPeriod Value as 2 (October–December) then FiscalQuarter is populated as - 2007-10-01T00:00:00.000+0000,\nFor FiscalPeriod Value as 3 (January–March) then FiscalQuarter is populated as - 2008-01-01T00:00:00.000+0000,\nFor FiscalPeriod Value 4 (April–June) then FiscalQuarter is populated as - 2008-04-01T00:00:00.000+0000)"
  },
  {
    "reverse_engineered_description": "Direct mapping to IsCurrentFiscalMonth column in DimTime table.",
    "comment": "Clarify the derivation logic and specify on which column this attribute is derived.",
    "final_description": "Direct mapping to IsCurrentFiscalMonth column in DimTime table coming from Commercial NextDay Datamart within SA&DP source having boolean values."
  },
  {
    "reverse_engineered_description": "Direct mapping to IsCurrentFiscalWeek column in DimTime table.",
    "comment": "Clarify the derivation logic and specify on which column this attribute is derived.",
    "final_description": "Direct mapping to IsCurrentFiscalWeek column in DimTime table coming from Commercial NextDay Datamart within SA&DP source having boolean values."
  },
  {
    "reverse_engineered_description": "Direct mapping to IsCurrentFiscalYear column in DimTime table.",
    "comment": "Clarify the derivation logic and specify on which column this attribute is derived.",
    "final_description": "Direct mapping to IsCurrentFiscalYear column in DimTime table coming from Commercial NextDay Datamart within SA&DP source having boolean values."
  },
  {
    "reverse_engineered_description": "Direct mapping to IsWeekday column in DimTime table.",
    "comment": "Clarify the derivation logic and specify on which column this attribute is derived.",
    "final_description": "Direct mapping to IsWeekday column in DimTime table coming from Commercial NextDay Datamart within SA&DP source having boolean values."
  },
  {
    "reverse_engineered_description": "This attribute has values like (-1, 1799, 3599, etc.) and is assigned based on conditions involving TimeOfDayId and time ranges.",
    "comment": "Please confirm whether these values are static or hardcoded. If they are static, they must be sourced from a static file provided by the business.",
    "final_description": "This attribute has static values of (-1, 1799, 3599, 5399, 7199 etc) provided by Commercial Business.\nWhen TimeOfDayId= -1, TimeOfDay3Hrs= 'Unknown' AND TimeOfDay1Hr= 'Unknown' then hardcoded as -1\nWhen TimeOfDayId= 0, TimeOfDay3Hrs= '00:00 To 02:59' AND TimeOfDay1Hr= '00:00 To 00:59' then hardcoded as 1799\nWhen TimeOfDayId= 1, TimeOfDay3Hrs= '00:00 To 02:59' AND TimeOfDay1Hr= '00:00 To 00:59' then hardcoded as 3599\nWhen TimeOfDayId= 2, TimeOfDay3Hrs= '00:00 To 02:59' AND TimeOfDay1Hr= '01:00 To 01:59' then hardcoded as 5399\nWhen TimeOfDayId= 3, TimeOfDay3Hrs='00:00 To 02:59' AND TimeOfDay1Hr= '01:00 To 01:59' then hardcoded as 7199\ngoes on until it's hardcoded as 86399"
  },
  {
    "reverse_engineered_description": "This attribute has values like ('Unknown', '00:00 To 00:59', etc.) assigned based on TimeOfDayId and time ranges.",
    "comment": "Please confirm whether these values are static or hardcoded. If they are static, they must be sourced from a static file provided by the business.",
    "final_description": "This attribute has static values of ('Unknown', '00:00 To 00:59', '00:00 To 00:59', '01:00 To 01:59', '01:00 To 01:59' etc) provided by Commercial Business.\nWhen TimeOfDayId= -1 AND TimeOfDay3Hrs= 'Unknown' then hardcoded as 'Unknown'\nWhen TimeOfDayId= 0 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '00:00 To 00:59'\nWhen TimeOfDayId= 1 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '00:00 To 00:59'\nWhen TimeOfDayId= 2 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '01:00 To 01:59'\nWhen TimeOfDayId= 3 AND TimeOfDay3Hrs='00:00 To 02:59' then hardcoded as '01:00 To 01:59'\ngoes on until it's hardcoded as '23:00 To 23:59'"
  },
  {
    "reverse_engineered_description": "This attribute has values assigned based on TimeOfDayId and time intervals.",
    "comment": "Please confirm whether these values are static or hardcoded. If they are static, they must be sourced from a static file provided by the business.",
    "final_description": "This attribute has static values of ('Unknown', '00:00 To 00:29', '00:30 To 00:59', '01:00 To 01:29', '01:30 To 01:59' etc) provided by Commercial Business.\nWhen TimeOfDayId= -1 AND TimeOfDay3Hrs= 'Unknown' then hardcoded as 'Unknown'\nWhen TimeOfDayId= 0 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '00:00 To 00:29'\nWhen TimeOfDayId= 1 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '00:30 To 00:59'\nWhen TimeOfDayId= 2 AND TimeOfDay3Hrs= '00:00 To 02:59' then hardcoded as '01:00 To 01:29'\nWhen TimeOfDayId= 3 AND TimeOfDay3Hrs='00:00 To 02:59' then hardcoded as '01:30 To 01:59'\ngoes on until it's hardcoded as 23:30 To 23:59'"
  },
  {
    "reverse_engineered_description": "This attribute is based on TimeOfDayId and mapped to specific time ranges.",
    "comment": "Please confirm whether these values are static or hardcoded. If they are static, they must be sourced from a static file provided by the business.",
    "final_description": "This attribute has static values of ('Unknown', '00:00 To 02:59' etc) provided by Commercial Business.\nWhen TimeOfDayId= -1 AND TimeOfDay1Hr= 'Unknown' then hardcoded as 'Unknown'\nWhen TimeOfDayId= 0, AND TimeOfDay1Hr= '00:00 To 00:59' then hardcoded as '00:00 To 02:59'\nWhen TimeOfDayId= 1, AND TimeOfDay1Hr= '00:00 To 00:59' then hardcoded as '00:00 To 02:59'\nWhen TimeOfDayId= 2, AND TimeOfDay1Hr= '01:00 To 01:59' then hardcoded as '00:00 To 02:59'\nWhen TimeOfDayId= 3, AND TimeOfDay1Hr= '01:00 To 01:59' then hardcoded as '00:00 To 02:59'\ngoes on until it's hardcoded as '21:00 To 23:59'"
  },
  {
    "reverse_engineered_description": "Surrogate key generated to identify unique records in the DimTimeOfDay table.",
    "comment": "Provide the logic for surrogate key generation, specifying which columns are involved.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimTimeOfDay table.\nWhen TimeOfDay3Hrs= 'Unknown' AND TimeOfDay1Hr= 'Unknown' AND Seconds= -1 then hardcoded as -1\nWhen TimeOfDay3Hrs= '00:00 To 02:59' TimeOfDay1Hr= '00:00 To 00:59' AND Seconds= 1799 then hardcoded as 0\nWhen TimeOfDay3Hrs= '00:00 To 02:59' TimeOfDay1Hr= '00:00 To 00:59' AND Seconds= 3599 then hardcoded as 1\nWhen TimeOfDay3Hrs= '00:00 To 02:59' TimeOfDay1Hr= '01:00 To 01:59' AND Seconds= 5399 then hardcoded as 2\nWhen TimeOfDay3Hrs='00:00 To 02:59' TimeOfDay1Hr= '01:00 To 00:59' AND Seconds= 7199 then hardcoded as 3\ngoes on until it's hardcoded as 47"
  },
  {
    "reverse_engineered_description": "This attribute has values ('Unknown', '<1Day', '1-<3 Days', '3-<7 Days', etc.) assigned based on TimeSpanKey.\nWhen TimeSpanKey = -1, it is assigned 'Unknown'.\nWhen TimeSpanKey = 1, it is assigned '<1Day'.\nWhen TimeSpanKey = 2, it is assigned '1-<3 Days'.\nWhen TimeSpanKey = 3, it is assigned '3-<7 Days'.\nWhen TimeSpanKey = 4, it is assigned '7-<14 Days'.",
    "comment": "Clarify whether these values are static (coming from a predefined file) or hardcoded. If static, specify the source.",
    "final_description": "This attribute has static values of (\"Unknown\", '<1Day', 1-<3 Days, 3-<7 Days, etc.) provided by Commercial Business.\nWhen TimeSpanKey = -1 then hardcoded as \"Unknown\"\nWhen TimeSpanKey = 1 then hardcoded as '<1Day'\nWhen TimeSpanKey = 2 then hardcoded as 1-<3 Days\nWhen TimeSpanKey = 3 then hardcoded as 3-<7 Days\nWhen TimeSpanKey = 4 then hardcoded as 7-<14 Days"
  },
  {
    "reverse_engineered_description": "SurrogateKey generated within UDP NRT to uniquely identify records in the DimTimeSpan table.\nWhen TimeSpan = \"Unknown\", it is assigned -1.\nWhen TimeSpan = '<1Day', it is assigned 1.\nWhen TimeSpan = '1-<3 Days', it is assigned 2.\nWhen TimeSpan = '3-<7 Days', it is assigned 3.\nWhen TimeSpan = '7-<14 Days', it is assigned 4.\nContinues until a maximum value of 8.",
    "comment": "Specify the logic used to generate the surrogate key, including which columns contribute to its creation.",
    "final_description": "SurrogateKey generated within UDP NRT to identify unique records of DimTimeSpan table.\nWhen TimeSpan = \"Unknown\" then hardcoded as -1\nWhen TimeSpan = '<1Day' then hardcoded as 1\nWhen TimeSpan = '1-<3 Days' then hardcoded as 2\nWhen TimeSpan = '3-<7 Days' then hardcoded as 3\nWhen TimeSpan = '7-<14 Days' then hardcoded as 4\ngoes on until it's hardcoded till 8."
  },
  {
    "reverse_engineered_description": "Derived from EXTENSIONATTRIBUTESSR and SupportAreaNames columns in SupportRequestDetailsSIPv2 Table.\nIf EXTENSIONATTRIBUTESSR = 1 OR SupportAreaNames contains 'OnPrem', it is assigned 'On-Prem'. Otherwise, it is assigned 'Cloud'.",
    "comment": "Use the standard decode logic format: 'Derived by applying decode logic to columns in tables from source'.",
    "final_description": "Derived by applying decode logic on EXTENSIONATTRIBUTESSR, SupportAreaNames columns in SupportRequestDetailsSIPv2 Table loaded from Rave data processed by Amplify Source.\nLogic: If EXTENSIONATTRIBUTESSR=1 OR SupportAreaNames like '%OnPrem%' then Hardcoded as \"On-Prem\" ELSE Hardcoded as \"Cloud\""
  },
  {
    "reverse_engineered_description": "This field references the DimGeography table to retrieve CustomerCountry details. The value is populated by joining the TenantCountry field from the SupportRequestDetailsSIPv2 table with the ISOCountryShortCode in the DimGeography table.",
    "comment": "Specify the source as UDPCommercial and provide the join condition used in the mapping.",
    "final_description": "This is a reference to DimGeography table to get details about the CustomerCountry. This CustomerCountry is populated by DimGeography.ISOCountryShortName by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from UDP Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "This field serves as a reference key to the DimGeography table for retrieving CustomerGeographyKey. The value is determined by joining the TenantCountry in the SupportRequestDetailsSIPv2 table with the ISOCountryShortCode in the DimGeography table.",
    "comment": "In the join logic, DimGeography (DimGeo) is not used.",
    "final_description": "This is a reference key to DimGeography table to get details about the CustomerGeographyKey. This key is populated by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "This field references the DimGeography table to retrieve CustomerGeographyLevel1Name. The value is populated by joining TenantCountry from the SupportRequestDetailsSIPv2 table with ISOCountryShortCode from the DimGeography table.",
    "comment": "Specify the source as UDPCommercial and provide the join condition.",
    "final_description": "This is a reference to DimGeography table to get details about the CustomerGeographyLevel1Name. This DimGeography.CustomerGeographyLevel1Name is populated by GeographyLevel1Name by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from UDP Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "This field references the DimGeography table to retrieve CustomerGeographyLevel2Name. The value is populated by joining TenantCountry from the SupportRequestDetailsSIPv2 table with ISOCountryShortCode from the DimGeography table.",
    "comment": "Specify the source as UDPCommercial and provide the join condition.",
    "final_description": "This is a reference to DimGeography table to get details about the CustomerGeographyLevel2Name. This CustomerGeographyLevel2Name is populated by DimGeography.GeographyLevel2Name by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from UDP Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "This field references the DimGeography table to retrieve CustomerGeographyLevel3Name. The value is populated by joining TenantCountry from the SupportRequestDetailsSIPv2 table with ISOCountryShortCode from the DimGeography table.",
    "comment": "Specify the source as UDPCommercial and provide the join condition.",
    "final_description": "This is a reference to DimGeography table to get details about the CustomerGeographyLevel3Name. This CustomerGeographyLevel3Name is populated by DimGeography.GeographyLevel3Name by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from UDP Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "This field references the DimGeography table to retrieve CustomerGeographyLevel4Name. The value is populated by joining TenantCountry from the SupportRequestDetailsSIPv2 table with ISOCountryShortCode from the DimGeography table.",
    "comment": "Specify the source as UDPCommercial and provide the join condition.",
    "final_description": "This is a reference to DimGeography table to get details about the CustomerGeographyLevel4Name. This CustomerGeographyLevel4Name is populated by DimGeography.GeographyLevel4Name by joining the TenantCountry in SupportRequestDetailsSIPv2 table coming from Amplify source with ISOCountryShortCode in the DimGeography table coming from UDP Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "Derived by applying decode logic on Skillids column in SupportRequestDetailsSIPv2 Table.\nIf Skillids contains '458754', it is assigned 'NOAM'.\nIf Skillids contains '458752', it is assigned 'EMEA'.\nIf Skillids contains '458755', it is assigned 'LATAM'.\nIf Skillids contains '458753', it is assigned 'APGC'.",
    "comment": "Refer row #37 where attribute is FiscalCumulativeWeek.",
    "final_description": "Derived by applying decode logic on Skillids column in SupportRequestDetailsSIPv2 Table loaded from Rave data processed by Amplify source.\nLogic: IF Skillids like '%,458754,%' THEN hardcoded as 'NOAM'\nWHEN Skillids like '%,458752,%' THEN hardcoded as 'EMEA'\nWHEN Skillids like '%,458755,%' THEN hardcoded as 'LATAM'\nWHEN Skillids like '%,458753,%' THEN hardcoded as 'APGC'."
  },
  {
    "reverse_engineered_description": "Directly mapped to the DeliverySubType column in SupportRequestDetailsSIPv2 table, which contains string values from the Rave data processed by Amplify source.",
    "comment": "Specify the source table for MDM rules and mention 'Business rules in form of Case When Conditions.' Clarify the role of DimDeliveryType—whether it is a source table or a reference table.",
    "final_description": "Direct Mapping to DeliverySubType column in SupportRequestDetailsSIPv2 table coming from Rave data processed by Amplify Source having string values."
  },
  {
    "reverse_engineered_description": "Reference key to DimDeliveryType table to retrieve DeliveryType details. The value is determined by joining DeliverySubType in DimDeliverySubType table with DeliverySubType in SupportRequestDetails table.",
    "comment": "Specify the source table for MDM rules and mention 'Business rules in form of Case When Conditions.' Clarify the role of DimDeliveryType—whether it is a source table or a reference table.",
    "final_description": "This is a reference key to the DimDeliveryType to get more details about DeliveryType. This DeliveryType is populated by joining DeliverySubType in DimDeliverySubType table with DeliverySubType in SupportRequestDetails table both the tables are coming from Rave data processed by Amplify source."
  },
  {
    "reverse_engineered_description": "Reference key to DimDeliveryType table to retrieve DeliveryTypeKey. The value is determined by joining DeliverySubType in DimDeliverySubType table with DeliverySubType in SupportRequestDetails table.",
    "comment": "Paraphrasing is inconsistent with similar attributes.",
    "final_description": "This is a reference key to the DimDeliveryType to get more details about DeliveryTypeKey. This DeliveryTypeKey is populated by joining DeliverySubType in DimDeliverySubType table with DeliverySubType in SupportRequestDetails table both the tables coming from Rave data processed by Amplify source."
  },
  {
    "reverse_engineered_description": "Reference key to DimEmployee table to retrieve EmployeeKey details. The value is determined by joining PartnerID in FactRequestNRT table with NativeAgentID in DimEmployeeMapping table.",
    "comment": "Ensure consistency in phrasing with similar reference key attributes. Logic paraphrasing should be clearer.",
    "final_description": "This is a reference key to the EmployeeKey to get more details about the DimEmployee. This key is populated by joining PartnerID in FactRequestNRT table coming from Commercial NRT Datamart within SA&DP with NativeAgentID in DimEmployeeMapping table coming from UDP Common Database for dynamics cases."
  },
  {
    "reverse_engineered_description": "Direct mapping to FiscalMonthName column in DimTime table, which contains string values and originates from UDPCommercial Next Day data.",
    "comment": "Explicitly mention the source as UDPCommercial.",
    "final_description": "Direct Mapping to FiscalMonthName column in DimTime Table coming from UDPCommercial Next Day having string values."
  },
  {
    "reverse_engineered_description": "Map to FiscalPeriod on DimTime table after UDPCommercial day, values are Integer.",
    "comment": "Mention the source as UDPCommercial to clarify where the data originates.",
    "final_description": "Direct Mapping to FiscalPeriod column in DimTime Table coming from UDPCommercial Next day having Integer values."
  },
  {
    "reverse_engineered_description": "Using Date_Diff function on AcknowledgeDateTime, CreateDateTime in SRD_SIPv2 from Rave by Amplify.",
    "comment": "Do not mention the Date_Diff function. Explain the logic in simple English, for example, state: 'Derived by calculating the time difference between the two datetime columns...'.",
    "final_description": "Derived using AcknowledgeDateTime and CreateDateTime columns in SupportRequestDetailsSIPv2 Table loaded from Rave data processed by Amplify source. \nLogic: We take Minutes difference between AcknowledgeDateTime and CreateDateTimec columns."
  },
  {
    "reverse_engineered_description": "Decode Rating column in SR. If NOT NULL, then 1, else 0.",
    "comment": "Remove the abbreviation 'SR.' and provide the full table name for clarity.",
    "final_description": "Derived by applying decode logic on Rating column in SupportRequestDetailsSIPv2 Table loaded from Rave data processed by Amplify.\nLogic: If Rating IS NOT NULL THEN 1 ELSE 0 END."
  },
  {
    "reverse_engineered_description": "Decode logic on CustomerFeedbackDateTime and Comment in SRDetails table loaded from Rave via Amplify. If CustomerFeedbackDateTime NOT NULL AND Comment NOT LIKE '&&#%' THEN true ELSE false.",
    "comment": "The paraphrasing used here is not suitable; ensure clarity by maintaining a straightforward description.",
    "final_description": "Derived by applying decode logic on CustomerFeedbackDateTime and Comment columns in SupportRequestDetailsSIPv2 Table loaded from Rave data processed by Amplify source.\nLogic: IF CustomerFeedbackDateTime IS NOT NULL AND Comment IS NOT NULL AND Comment NOT LIKE '&#%' AND Comment not equal to 'null' AND Comment not equal to 'sovereignscrubbed'\nAND Comment not equal to 'unspecified' THEN True ELSE False"
  },
  {
    "reverse_engineered_description": "Decode logic on ChannelOrgCode,FunctionHierarchyKey,ChannelOrgSummaryName, IsCEnS in DimFunctionHierarchy table from MDM. If lower(ChannelOrgCode)='b20e' Then true Else false.",
    "comment": "Please refer to the example provided in the guidelines for this column to ensure proper usage.",
    "final_description": "Derived by applying decode logic on ChannelOrgCode,FunctionHierarchyKey,ChannelOrgSummaryName, IsCEnS columns DimFunctionHierarchy table coming from MDM source. \nLogic:\n          If lower(ChannelOrgCode)='b20e' Then true\n          If FunctionHierarchyKey=-1 or ChannelOrgSummaryName='Unknown' or FunctionHierarchyKey is Null THEN\n              CASE \n              If   MDM.IsCEnS is not null then Cast(MDM.IsCEnS as Boolean)\n              Else true\n              END\n         WHEN lower(ChannelOrgCode)<>'b20e' Then false\n          Else true\n          END AS IsCEnS "
  },
  {
    "reverse_engineered_description": "Decode logic on SponsoredStrategicFlag in TP. DimCalc table from Comm NextDay Datamart in SA&DP. Null, No else flag generated.",
    "comment": "Specify the data source. Remove 'TP.' or provide the full table name and adhere to proper indentation.",
    "final_description": "Derived by applying decode logic on SponsoredStrategicFlag colum in  DimCalc table loaded from Commercial NextDay Datamart within SA&DP. \nLogic:IF SponsoredStrategicFlag IS NULL THEN 'No' ELSE SponsoredStrategicFlag END AS IsStrategicFlag."
  },
  {
    "reverse_engineered_description": "Indirect mapping using SupportRequestDetailsSIPv2 and static RavePlanningCategories based on CaseType, IssueType, TenantName, ProgramId. Values joined via key columns SupportAreaName, OrganizationId, RequestId.",
    "comment": "Include the table name from MDM and mention 'Business rules' to clarify the business logic involved.",
    "final_description": "This column is an indirect mapping derived from two sources:  SupportRequestDetailsSIPv2 Table coming from Rave data processed by Amplify Source and the static RavePlanningCategories table. It's mapped based on the CaseType,IssueType, TenantName ,ProgramId columns from the SupportRequestDetailsSIPv2 table, and the values are obtained through specific joins involving key columns like \"SupportAreaName,\" \"OrganizationId,\" and \"RequestId.\""
  },
  {
    "reverse_engineered_description": "Decode logic on SupportAreaName, SubscriptionType, SkillIds, ProgramId in SRDetails_INC table from Rave via Amplify. CASE statements determine ServiceOfferingKey.",
    "comment": "Identify the source of the FactRequest table to provide more context on the data's origin.",
    "final_description": "Derived by applying decode logic on SupportAreaName, SubscriptionType, SkillIds and ProgramId columns in SupportRequestDetailsSIPv2_INC table coming from Rave data processed by Amplify Source.\nLogic: CASE WHEN  SupportAreaName = 'proactive' THEN hardcoded as 1 \n        WHEN SupportAreaName Like 'premier%' AND SubscriptionType = 2 THEN hardcoded as 2\n        WHEN SkillIds Like ('%589825%' or '%393216%' or '%589824%') AND (SubscriptionType IS NULL or not equal to 2) THEN hardcoded as 2 \n        WHEN ProgramId = '5c44c5ec-5fd4-4e45-ab0d-dd9156d1bde9' AND (SubscriptionType IS NULL or not equal to 2) THEN hardcoded as 2\n        ELSE 3 END AS ServiceOfferingKey"
  },
  {
    "reverse_engineered_description": "Reference attribute to DimTheme for Technology with join on Theme in SRDetails from Rave via Amplify and Theme in DimTheme from Comm NextDay within SA&DP.",
    "comment": "Use the following statement format: ensure business rules in the form of a CASE WHEN statement are applied on SupportAreaName, which is maintained by Modern Workspace business.",
    "final_description": "This is a reference attribute to DimTheme table to get details of the Technology. Logic: Technology is populated by joining the Theme column in SupportRequestDetailsSIPv2 table coming from Rave data processed by Amplify Source with Theme column in the DimTheme table coming from Commercial NextDay Datamart within SA&DP."
  },
  {
    "reverse_engineered_description": "Reference attribute to DimGeography to fetch ISOCountryShortName by joining TenantCountry in SupportRequestDetails_NRT (intermediate) and ISOCountryShortCode in DimGeography.",
    "comment": "Since SupportRequestDetails_NRT is an enrichment file, can we label it as an 'intermittent file' in brackets? Also, let's apply this update at the entity level description, as it pertains to all attributes.",
    "final_description": "This is reference attribute to the DimGeography table to get more details about the ISOCountryShortName. It is populated by joining TenantCountry column in SupportRequestDetails_NRT intermediate table (refer entity desc for SupportRequestDetails_NRT table derivation) with ISOCountryShortCode column in DimGeography table coming from Commercial NextDay Datamart within SA&DP"
  },
  {
    "reverse_engineered_description": "Surrogate key in UDP NRT to uniquely identify records in FactRaveUnAssignedSnapshot table using RequestId.",
    "comment": "Please provide the detailed logic on how the surrogate key is generated, indicating the columns involved in the process.",
    "final_description": "Surrogate key generated within UDP NRT to identify unique records of FactRaveUnAssignedSnapshot table. It is generated using RequestId column."
  },
  {
    "reverse_engineered_description": "Decode logic on RequestAge_Days in SRDetails_NRT with string values. CASE logic assigns age bucket labels.",
    "comment": "Enhance the paraphrasing for clarity and ensure the sequence of logic is easy to understand.",
    "final_description": "Derived by applying decode logic on RequestAge_Days column in SupportRequestDetails_NRT intermediate table having string values (refer entity desc for SupportRequestDetails_NRT table derivation).\nLogic:CASE WHEN RequestAge_Days <= 1 Then hardcoded as '00-01 day'\n\tWHEN RequestAge_Days > 1 AND RequestAge_Days <= 3 Then hardcoded as '01-03 days'\n\tWHEN RequestAge_Days > 3 AND RequestAge_Days <= 7 Then hardcoded as '03-07 days'\n\tWHEN RequestAge_Days > 7 AND RequestAge_Days <= 14 Then hardcoded as '07-14 days'\n\tWHEN RequestAge_Days > 14 AND RequestAge_Days <= 21 Then hardcoded as '14-21 days'\n\tWHEN RequestAge_Days > 21 AND RequestAge_Days <= 30 Then hardcoded as '21-30 days'\n\tWHEN RequestAge_Days > 30 AND RequestAge_Days <= 60 Then hardcoded as '30-60 days'\n\tWHEN RequestAge_Days > 60 AND RequestAge_Days <= 90 Then hardcoded as '60-90 days'\n\tWHEN RequestAge_Days > 90 Then hardcoded as '90+ days'\n\tEND AS SRAgeBucket"
  },
  {
    "reverse_engineered_description": "Reference Key to DimCauseType for CauseTypeKey via join on CauseType in Cases from DFM processed by Cornerstone and CauseType in DimCauseType from Comm NextDay within SA&DP.",
    "comment": "Please mention the source to clearly define the origin of the data.",
    "final_description": "This is reference Key to the DimCauseType table to get more details about CauseTypeKey. This key is populated by joining CauseType column in Cases table coming from DFM Events data processed by Cornerstone with CauseType in the DimCauseType coming from Commercial NextDay Datamart within SA&DP.."
  },
  {
    "reverse_engineered_description": "Decode logic on KPIState in DimKPIState from Commercial NextDay and State, Name, SRNumber in KPIFlash table. Join on DimKPIState and KPIFlash to fetch max StateKey.",
    "comment": "Revisit the paraphrasing, as step 3 is not clearly articulated. Ensure each step logically flows and is easy to follow.",
    "final_description": "Derived by applying decode logic on KPIState column in DimKPIState table coming from Commercial NextDay Datamart within SA&DP and  State, Name and SRNumber columns in KPIFlash intermediate table.\nKPIFLASH: This intermediate table is derived from KPI table coming from DFM Events data processed by Cornerstone by taking SRNumber, max of State column by grouping on SRNumber and Lower(Name) \nLogic -  \nStep-1: DimKPIState table is joined with KPIFLASH intermediate table on join condition DimKPIState.KPIState = KPIFLASH.State and LOWER(KPIFLASH.Name) = 'fcr' to pick max of DimKPIState.KPIStateKey grouped by on KPIFLASH.SRNumber\nStep-2: If KPIStateKey derived in step 1 is NULL then hardcoded as -1 else whatever value coming in KPIStateKey is populated."
  },
  {
    "reverse_engineered_description": "Decode logic on KPIState in DimKPIState from Commercial NextDay and State, Name, SRNumber in KPIFlash table. Join on DimKPIState and KPIFlash to fetch max StateKey.",
    "comment": "Please reconsider the description as there are areas that need clarification to effectively communicate the process described.",
    "final_description": "Derived by applying decode logic on KPIState column in DimKPIState table coming from Commercial NextDay Datamart within SA&DP and  State, Name and SRNumber columns in KPIFlash intermediate table.\nKPIFLASH: This intermediate table is derived from KPI table coming from DFM Events data processed by Cornerstone by taking SRNumber, max of State column by grouping on SRNumber and Lower(Name) \nLogic -  \nStep-1: DimKPIState table is joined with KPIFLASH intermediate table on join condition DimKPIState.KPIState = KPIFLASH.State and LOWER(KPIFLASH.Name) = 'fdr' to pick max of DimKPIState.KPIStateKey grouped by on KPIFLASH.SRNumber\nStep-2: If KPIStateKey derived in step 1 is NULL then hardcoded as -1 else whatever value coming in KPIStateKey is populated."
  },
  {
    "reverse_engineered_description": "Decode logic on CompletedDateTime and ExpireDateTime from Cases for initialresponse. Max of CompletedDateTime determines 'Missed', 'Met', or 'Unknown'.",
    "comment": "The condition has been checked: ensure clarity when comparing max CompletedDateTime with max ExpireDateTime for initialresponse cases.",
    "final_description": "Derived by applying decode logic based on CompletedDateTime, ExpireDateTime, SlaType columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic : Step 1- We consider the max value of CompletedDateTime and ExpireDateTime columns when SlaType = 'initialresponse'\nStep 2- If max of CompletedDateTime is greater than ExpireDateTime then hardcoded as 'Missed'\nStep 3- If max of CompletedDateTime is less than or equal to ExpireDateTime then hardcoded as 'Met' Else 'Unknown' END AS  IRStatus"
  },
  {
    "reverse_engineered_description": "IRStatusKey indirect mapping from DimIRStatus and SlaItem via join on IRStatus. Replace NULL with -1.",
    "comment": "Verify the line referencing 'IdleTimeSpanKey is NULL from step 1' to ensure accuracy and consistency.",
    "final_description": "Indirect mapping to IRStatusKey in DimIRStatus table coming from Commercial NRT Datamart within SA&DP.\nLogic: Step1- It is fetched by joining IRStatus column in DimIRStatus table with IRStatus column in SlaItem table coming from DFM Events data processed by Cornerstone.\nStep2- If IRStatusKey is NULL from step1 then replaces it with -1."
  },
  {
    "reverse_engineered_description": "Decode logic using TenantName, DataSourceKey, QueueName, EmployeeEmail, etc., from various tables. Set IsCubeFlag based on conditions.",
    "comment": "Developers should check this description to ensure accuracy of logic involving multiple columns and tables for determining IsCubeFlag.",
    "final_description": "Derived by applying decode logic on TenantName column in DimTenant table, DataSourceKey column in DimDataSource table, QueueName column in DimQueue table coming from Commercial NextDay Datamart within SA&DP, EmployeeEmail and CSCompanyAgency columns in DimEmployee table coming from UDP Common Database for dynamics cases, PreviousRoutingQueueName column in SREvents table coming from DFM Events data processed by Cornerstone and SupportAreaName column in FactSRSupportData table coming from Commercial NRT Datamart within SA&DP \nLogic:CASE WHEN TenantName LIKE '%contoso%' OR 'mstest_%' OR 'test_test_%' OR 'test' OR 'msft' THEN 0\n\t            WHEN DataSourceKey = 203 AND EmployeeEmail NOT LIKE '%offagent%'\n                                AND CSCompanyAgency NOT IN ('Avande', 'Experis', 'Mural', 'Rhipe', 'Sherweb', 'Subfero Ltd', 'Zones Inc')\n\t\t\t\tAND WHEN QueueName OR PreviousRoutingQueueName NOT IN ( 'MSaaS Rave Transfers', 'Engineering')\n\t\t\t\tAND SupportAreaName NOT LIKE '%test%' OR SupportAreaName NOT LIKE '%lab%'\n\t\t   THEN 1 ELSE 0 END AS IsCubeFlag"
  },
  {
    "reverse_engineered_description": "Decode based on ServiceRequestID and DataSourceKey in Cases and DimDataSource. Check DataSourceKey for path and set return string.",
    "comment": "Revamp the description to include paraphrasing; clearly outline steps involved using concise logic.",
    "final_description": "Derived by applying decode logic based on ServiceRequestID column in Cases table coming from DFM Events data processed by Cornerstone and DataSourceKey column in DimDataSource table coming from Commercial NextDay Datamart within SA&DP.\nLogic: Step 1- If DatasourceKey=3 it then goes to step 2 else step 3.\nStep2- If ServiceRequestID column is not NULL then it's hardcoded as 'Yes' else 'No'. \nStep3- It assigns the value 'Unknown'."
  },
  {
    "reverse_engineered_description": "Decode logic on CompletedOn and CreatedDateTime from Cases. Calculate minute difference and set based on threshold.",
    "comment": "The paraphrasing is missing; please rewrite the description to effectively present the logic step-by-step.",
    "final_description": "Derived by applying decode logic on CompletedOn and CreatedDateTime columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic: Step 1- Calculates time difference in minutes between CompletedOn and CreatedDateTime columns in Cases table. \nStep 2- If the value from step 1 is less than or equal to 30 minutes it's hardcoded as 1 else 0."
  },
  {
    "reverse_engineered_description": "Map to PlanningCategoryKey in FactSupportServiceRequest from Commercial NextDay, integer values.",
    "comment": "Please include the logic for generating the surrogate key, detailing the columns utilized in its creation.",
    "final_description": "Direct mapping to PlanningCategoryKey column in FactSupportServiceRequest table comng from Commercial NextDay Datamart within SA&DP source having integer values."
  },
  {
    "reverse_engineered_description": "Decode based on Row_InitialPreviousRoutingContext and EventDateTime in SREvents from DFM. Join for QueueKey, alias as PreviousAssignedQueueKey.",
    "comment": "Rewrite the description to clarify the significance of queueKey. Confirm if it is a reference key; if not, ensure the description accurately reflects its usage.",
    "final_description": "Derived by applying decode logic based on Row_InitialPreviousRoutingContext, EventDateTime columns in SREvents table coming from DFM Events data processed by Cornerstone.\nLogic: - Step1- WHEN Row_InitialPreviousRoutingContext = 1 from SREvents table then we consider QueueKey from DimQueue table coming from Commercial NextDay Datamart within SA&DP by joining PreviousRoutingContextId in SREvents table with NativeQueueID in DimQueue table.\nStep2- The QueueKey fetched from step1 is aliased as PreviousAssignedQueueKey."
  },
  {
    "reverse_engineered_description": "Decode logic on ServiceRequestID from Cases with key. Extract date without hyphen for integer type.",
    "comment": "Revise the logic description to explicitly state the process of extracting the date from CreatedDateTime by removing the hyphen.",
    "final_description": "Derived attribute of datatype int based on CreatedDateTime column in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic:Step1-  It fetches the date portion from CreatedDateTime and removes hyphens from it.\nStep2-If SRCreatedDateTimeId from step1 has null values then it replaces it with -1."
  },
  {
    "reverse_engineered_description": "Int attribute based on CreatedDateTime in Cases from DFM data. Joins on SRNumber of FactSupportData and Cases. Calculate seconds from midnight for CreatedDateTime, round to nearest 30 min, subtract 1, alias SRCreatedDateTimeSeconds.",
    "comment": "The logic for the calculation is unclear. Please verify the steps and ensure the logic follows a coherent sequence.",
    "final_description": "Derived attribute of datatype int based on CreatedDateTime column in Cases table from DFM data processed by Cornerstone.It is joined using SRNumber from both FactSupportData and Cases table.\nLogic:Step1- It calculates the number of seconds passed since the start of the day (midnight) for a given CreatedDateTime. \n           Step2- It then rounds the value fetched from step1 up to the nearest 30-minute interval and subtracts 1 second and aliased as SRCreatedDateTimeSeconds.\n\nExample: The CreatedDateTime is 2024-03-07 15:25:30,\n                Step1 : Calculate Seconds from 12 am and the time difference is 15 h 25 min 30 sec, which equals to 55,530 seconds.\n                Step 2: Divide 55,530 sec by 1800 (seconds in 30 minutes), resulting in 30.85 and round off which would be 31 mins.\n                Step 3: Multiply 31 min (from step 2) by 1800 to get Seconds in 30-minute Increments that is 55,800 seconds.\n                 Step 4: Subtract 1 second from 55,800 seconds, resulting in 55,799 seconds end as SRCreatedDateTimeSeconds.\n"
  },
  {
    "reverse_engineered_description": "Surrogate key in UDP NRT for FactSREvents, generated via SRNumber.",
    "comment": "Please explain the logic for generating the surrogate key, specifically detailing the columns that are involved in its creation.",
    "final_description": "Surrogate key generated within UDP NRT to identify unique records of FactSREvents table.It is generated using SRNumber."
  },
  {
    "reverse_engineered_description": "Decode logic on EventDateTime in DFM Events. Extract date, replace null with -1.",
    "comment": "Update the logic by referring to the approach used for the SRCreatedDateTimeId column to ensure consistency and completeness.",
    "final_description": "Derived by applying decode logic on EventDateTime column in DFM Events data processed by Cornerstone.\nLogic: Step1- It extracts the date portion of EventDateTime.\nStep2- If SRModifiedTimeId from step1 has null values then it's replaced with -1."
  },
  {
    "reverse_engineered_description": "Decode on StateAnnotation and EventDateTime in Cases from DFM. Extract date where StateAnnotation matches, replace null with -1.",
    "comment": "Use the SRCreatedDateTimeId logic for an update to ensure coherence and completeness of the description.",
    "final_description": "Derived by applying decode logic on StateAnnotation and EventDateTime columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic:Step1 - It extracts the date portion of \"EventDateTime\" WHEN \"StateAnnotation\"= ('identifying the issue', 'identifying issue', 'scope').\nStep2 - If step 1 fetches null values then ut replaced with -1"
  },
  {
    "reverse_engineered_description": "Decode logic on IncidentType, CaseType in Cases from DFM having strings. Conditional check then assign value for SRType or 'Unknown'.",
    "comment": "Please structure the logic explanation into clear steps to ensure readability and understanding.",
    "final_description": "Derived by applying decode logic on IncidentType and CaseType columns in Cases table coming from DFM Events data processed by Cornerstone having string values.\nLogic :\nStep 1 : It checks if a certain condition involving IncidentType column in FactSRSupportData table coming from Commercial NRT Datamart within SA&DP is true. \nStep 2: If Step 1 is true, then it checks the value of SRType column in Cases table coming from DFM Events data processed by Cornerstone and assigns specific values based on different scenarios. \nStep 3: If the initial condition from Step 1 is false, it returns the result as 'Unknown'."
  },
  {
    "reverse_engineered_description": "Decode on Severity in Cases from DFM. Group by SR Number, order by Eventdatetime; get first Severity.",
    "comment": "Define the significance of 'A' in this context. Check the logic section and consider updates, such as: 'Take the first value of the severity column by grouping on SR number...'",
    "final_description": "Dervied by applying decode logic on column Severity loaded from Cases table from DFM Events data processed by Cornerstone. Logic: Taking the first value of Severity column from Cases entity by grouping on SR Number and order by based on Eventdatetime."
  },
  {
    "reverse_engineered_description": "Direct map to ARRTypeDerived in FactSREvents from Commercial NRT with strings.",
    "comment": "Please provide the significance of FI and break down the description using IF-ELSE statements for clarity.",
    "final_description": "Direct Mapping to ARRTypeDerived column in FactSREvents table coming from Commercial NRT Datamart within SA&DP having string values."
  },
  {
    "reverse_engineered_description": "Static values (Unknown, Critical) in field provided by Commercial Business, uploaded via flat file.",
    "comment": "Ensure the description is properly phrased, especially for text highlighted in red. Mention the entity related to ExpiresDateTime.",
    "final_description": "This attribute has static values of (Unknown,Critical) provided by Commercial Business and uploaded through flat file."
  },
  {
    "reverse_engineered_description": "Decode on SRCreationDateTime in FactSREvents from Commercial NRT. Assign region based on time.",
    "comment": "Clarify the significance and role of FI in this description.",
    "final_description": "Derived by applying decode logic on column SRCreationDateTime in FactSREvents from Commercial NRT Datamart within SA&DP source.\nLogic:\nWHEN (SRCreationDateTime) BETWEEN 1 AND 8 THEN 'Asia'\nWHEN (SRCreationDateTime) BETWEEN 9 AND 16 THEN 'EMEA'\nWHEN (SRCreationDateTime) BETWEEN 17 AND 24 OR HOUR(SRCreationDateTime)=0 THEN 'Americas' END AS ManagementAccountableForSR"
  },
  {
    "reverse_engineered_description": "Decode on SLAExpiresTime, SLACompletedTime from SLAEvents, derive time difference, set flags based on conditions.",
    "comment": "Explain the significance of the SLA acronym within this context.",
    "final_description": "Derived by applying decode logic on column SLAExpiresTime, SLACompletedTime from SLAEvents from Commercial NRT Datamart within SA&DP source.\nLogic: Calculates the time difference in minutes between SLAExpiresTime and either the Current Timestamp or SLACompletedTime, if SLACompletedTime is null. If the conditions are not met, it returns 0; otherwise 1."
  },
  {
    "reverse_engineered_description": "Decode MinutesPastSLA in FactSREvents from Commercial NRT. Group minutes into ranges: '>5 Days', '>3 Days', '>1 Day', '>8 Hours', '< 8 Hours'.",
    "comment": "Please clarify the significance of 'FI' in this context to ensure the reader understands its role or meaning.",
    "final_description": "Derived by applying decode logic on column MinutesPastSLA from FactSREvents from Commercial NRT Datamart within SA&DP source.\nLogic: It calculates the MinutesPastSLA into different time ranges and providing corresponding labels.\n1)WHEN MinutesPastSLA > 7200 THEN '>5 Days'\n2)WHEN MinutesPastSLA > 4320 THEN '>3 Days'\n3)WHEN MinutesPastSLA > 1440 THEN '>1 Day'\n4)WHEN MinutesPastSLA > 480 THEN '>8 Hours'\n5)ELSE '< 8 Hours'."
  },
  {
    "reverse_engineered_description": "Decode MinutesPastSLA in FactSREvents from Commercial NRT. Format as string showing days and hours. Null results if no value.",
    "comment": "Can you define the significance of 'FI' in this description to provide better context for its use?",
    "final_description": "Derived by applying decode logic on column MinutesPastSLA from FactSREvents from Commercial NRT Datamart within SA&DP source.\nLogic: It takes the MinutesPastSLA duration and formats it into a string representation of days and hours (e.g., \"2 D | 4 H\"). If MinutesPastSLA is null, the result is also null."
  },
  {
    "reverse_engineered_description": "Decode MinutesPastSLA in FactSREvents assigns priority levels. Priority 1 for >7200, 2 for >4320, 3 for >1440, 4 for >480, else 5.",
    "comment": "Expand on the 'FI' term so readers can fully grasp its significance in this logic statement.",
    "final_description": "Derived by applying decode logic on column MinutesPastSLA from FactSREvents from Commercial NRT Datamart within SA&DP source.\nLogic: It evaluates the value of MinutesPastSLA and assigns a priority level based on different conditions.\n1)WHEN MinutesPastSLA > 7200 THEN 1: If MinutesPastSLA is greater than 7200 (which corresponds to 5 days), it assigns a priority level of 1.\n2)WHEN MinutesPastSLA > 4320 THEN 2: If MinutesPastSLA is between 4320 (3 days) and 7200 (5 days), it assigns a priority level of 2.\n3)WHEN MinutesPastSLA > 1440 THEN 3: If MinutesPastSLA is between 1440 (1 day) and 4320 (3 days), it assigns a priority level of 3.\n4)WHEN MinutesPastSLA > 480 THEN 4: If MinutesPastSLA is between 480 minutes (8 hours) and 1440 (1 day), it assigns a priority level of 4.\nELSE 5) If none of the above conditions are met, it assigns a priority level of 5."
  },
  {
    "reverse_engineered_description": "Decode logic on State, StateLastUpdatedDateTime, CreatedDateTime in Cases from DFM. Open calculates hours from current time, Closed from StateLastUpdated. Otherwise assigns 0.",
    "comment": "What does 'FI' indicate? Please explain this term. Consider paraphrasing the logic into a clear format like 'case when...' or 'if else...'.",
    "final_description": "Derived by applying decode logic on State, StateLastUpdatedDateTime and CreatedDateTime columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic:  When State ='Open' it calculates the difference in hours between Current Timestamp and CreatedDateTime column in Cases table.\n               When State ='Closed' it calculates the difference in hours between StateLastUpdatedDateTime and CreatedDateTime columns in Cases table.\n                If the result when either of the above conditions met it assign 1 else it assign 0 when any of the DateTime column is null."
  },
  {
    "reverse_engineered_description": "Decode SRCreationDateTime in FactSREvents from Commercial NRT. Calculate minutes between current and creation time, label as SRCreationMinutes.",
    "comment": "Clarify what 'FI' stands for. Use 'current timestamp' instead of 'unix timestamp' in the logical explanation.",
    "final_description": "Derived by applying decode logic on column SRCreationDateTime in FactSREvents table coming from Commercial NRT Datamart within SA&DP source having integer values.\nLogic:  It calculates the number of minutes that have passed between the current time and the SRCreationDateTime from FactSREvents table and labels this duration as \"SRCreationMinutes.\""
  },
  {
    "reverse_engineered_description": "Decode logic on CompletedDateTime, Type, CreatedDateTime in Cases from DFM. Compute minute difference when Type is InitialResponse.",
    "comment": "Include the term 'column' when referring to 'type.' Ensure the sentence is properly phrased, especially highlighted sections.",
    "final_description": "Derived by applying decode logic CompletedDateTime,Type and CreatedDateTime columns in Cases table coming from DFM Events data processed by Cornerstone.\nLogic: It calculates minute difference between CompletedDateTime and CreatedDateTime columns When Type = 'InitialResponse' in Cases table."
  },
  {
    "reverse_engineered_description": "Reference Key to DimCauseType for CauseTypeKey. Joining on CauseType in Cases and DimCauseType from Comm NextDay.",
    "comment": "Please specify the source to guide the understanding of the data's origin.",
    "final_description": "This is reference Key to the DimCauseType table to get more details about CauseTypeKey. This key is populated by joining CauseType column in Cases table coming from DFM Events data processed by Cornerstone with CauseType in the DimCauseType coming from Commercial NextDay Datamart within SA&DP.."
  },
  {
    "reverse_engineered_description": "Decode KPIState in DimKPIState, State, Name, SRNumber in KPIFlash. Join tables, verify conditions, extract max KPIStateKey.",
    "comment": "Please revisit and clarify the paraphrasing for step 3 to ensure transparency in the sequence of actions.",
    "final_description": "Derived by applying decode logic on KPIState column in DimKPIState table coming from Commercial NextDay Datamart within SA&DP and  State, Name and SRNumber columns in KPIFlash intermediate table.\nKPIFLASH: This intermediate table is derived from KPI table coming from DFM Events data processed by Cornerstone by taking SRNumber, max of State column by grouping on SRNumber and Lower(Name) \nLogic -  \nStep-1: DimKPIState table is joined with KPIFLASH intermediate table on join condition DimKPIState.KPIState = KPIFLASH.State and LOWER(KPIFLASH.Name) = 'fcr' to pick max of DimKPIState.KPIStateKey grouped by on KPIFLASH.SRNumber\nStep-2: If KPIStateKey derived in step 1 is NULL then hardcoded as -1 else whatever value coming in KPIStateKey is populated."
  },
  {
    "reverse_engineered_description": "Decode KPIState in DimKPIState, State, Name, SRNumber in KPIFlash. Join tables, verify conditions, extract max KPIStateKey.",
    "comment": "Please revisit the description for clarity and ensure the explanation aligns with the intended logic.",
    "final_description": "Derived by applying decode logic on KPIState column in DimKPIState table coming from Commercial NextDay Datamart within SA&DP and  State, Name and SRNumber columns in KPIFlash intermediate table.\nKPIFLASH: This intermediate table is derived from KPI table coming from DFM Events data processed by Cornerstone by taking SRNumber, max of State column by grouping on SRNumber and Lower(Name) \nLogic -  \nStep-1: DimKPIState table is joined with KPIFLASH intermediate table on join condition DimKPIState.KPIState = KPIFLASH.State and LOWER(KPIFLASH.Name) = 'fdr' to pick max of DimKPIState.KPIStateKey grouped by on KPIFLASH.SRNumber\nStep-2: If KPIStateKey derived in step 1 is NULL then hardcoded as -1 else whatever value coming in KPIStateKey is populated."
  },
  {
    "reverse_engineered_description": "Decode based on CompletedDateTime, ExpireDateTime, SlaType in Cases. Max CompletedDateTime defines 'Missed' or 'Met', else 'Unknown'.",
    "comment": "The condition has been verified: specifically check when CompletedDateTime is greater than ExpireDateTime for initialresponse cases.",
    "final_description": "Derived by applying decode logic based on CompletedDateTime, ExpireDateTime, SlaType columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic : Step 1- We consider the max value of CompletedDateTime and ExpireDateTime columns when SlaType = 'initialresponse'\nStep 2- If max of CompletedDateTime is greater than ExpireDateTime then hardcoded as 'Missed'\nStep 3- If max of CompletedDateTime is less than or equal to ExpireDateTime then hardcoded as 'Met' Else 'Unknown' END AS  IRStatus"
  },
  {
    "reverse_engineered_description": "Indirect mapping to IRStatusKey in DimIRStatus from Commercial NRT. Join IRStatus in DimIRStatus and SlaItem. Replace null with -1.",
    "comment": "Please check the reference to 'IdleTimeSpanKey is NULL from step 1' and ensure the correct key is being mentioned.",
    "final_description": "Indirect mapping to IRStatusKey in DimIRStatus table coming from Commercial NRT Datamart within SA&DP.\nLogic: Step1- It is fetched by joining IRStatus column in DimIRStatus table with IRStatus column in SlaItem table coming from DFM Events data processed by Cornerstone.\nStep2- If IRStatusKey is NULL from step1 then replaces it with -1."
  },
  {
    "reverse_engineered_description": "Decode logic on TenantName, DataSourceKey, QueueName, EmployeeEmail, CSCompanyAgency, PreviousRoutingQueueName, SupportAreaName from various tables, determine IsCubeFlag value.",
    "comment": "This needs to be verified by the developer to ensure the code logic aligns with the intended outcome.",
    "final_description": "Derived by applying decode logic on TenantName column in DimTenant table, DataSourceKey column in DimDataSource table, QueueName column in DimQueue table coming from Commercial NextDay Datamart within SA&DP, EmployeeEmail and CSCompanyAgency columns in DimEmployee table coming from UDP Common Database for dynamics cases, PreviousRoutingQueueName column in SREvents table coming from DFM Events data processed by Cornerstone and SupportAreaName column in FactSRSupportData table coming from Commercial NRT Datamart within SA&DP \nLogic:CASE WHEN TenantName LIKE '%contoso%' OR 'mstest_%' OR 'test_test_%' OR 'test' OR 'msft' THEN 0\n\t            WHEN DataSourceKey = 203 AND EmployeeEmail NOT LIKE '%offagent%'\n                                AND CSCompanyAgency NOT IN ('Avande', 'Experis', 'Mural', 'Rhipe', 'Sherweb', 'Subfero Ltd', 'Zones Inc')\n\t\t\t\tAND WHEN QueueName OR PreviousRoutingQueueName NOT IN ( 'MSaaS Rave Transfers', 'Engineering')\n\t\t\t\tAND SupportAreaName NOT LIKE '%test%' OR SupportAreaName NOT LIKE '%lab%'\n\t\t   THEN 1 ELSE 0 END AS IsCubeFlag"
  },
  {
    "reverse_engineered_description": "Decode logic based on ServiceRequestID in Cases and DataSourceKey in DimDataSource. Determine specific values for conditions.",
    "comment": "The description needs to be rewritten, focusing on paraphrasing and improving clarity while explaining the steps.",
    "final_description": "Derived by applying decode logic based on ServiceRequestID column in Cases table coming from DFM Events data processed by Cornerstone and DataSourceKey column in DimDataSource table coming from Commercial NextDay Datamart within SA&DP.\nLogic: Step 1- If DatasourceKey=3 it then goes to step 2 else step 3.\nStep2- If ServiceRequestID column is not NULL then it's hardcoded as 'Yes' else 'No'. \nStep3- It assigns the value 'Unknown'."
  },
  {
    "reverse_engineered_description": "Decode on CompletedOn and CreatedDateTime in Cases. Calculate time difference, assign value based on 30-minute threshold.",
    "comment": "The current description lacks paraphrasing; rewrite it for better clarity of logic and flow.",
    "final_description": "Derived by applying decode logic on CompletedOn and CreatedDateTime columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic: Step 1- Calculates time difference in minutes between CompletedOn and CreatedDateTime columns in Cases table. \nStep 2- If the value from step 1 is less than or equal to 30 minutes it's hardcoded as 1 else 0."
  },
  {
    "reverse_engineered_description": "Directly map to PlanningCategoryKey in FactSupportServiceRequest from Commercial NextDay, has integer values.",
    "comment": "Please provide the logic for surrogate key generation, specifically highlighting which columns are involved.",
    "final_description": "Direct mapping to PlanningCategoryKey column in FactSupportServiceRequest table comng from Commercial NextDay Datamart within SA&DP source having integer values."
  },
  {
    "reverse_engineered_description": "Decode logic on Row_InitialPreviousRoutingContext and EventDateTime in SREvents. When context = 1, determine QueueKey from join.",
    "comment": "Please rewrite the description to clarify the significance of QueueKey. Confirm if it is a reference key; if not, update the description properly.",
    "final_description": "Derived by applying decode logic based on Row_InitialPreviousRoutingContext ,EventDateTime columns in SREvents table coming from DFM Events data processed by Cornerstone .\nLogic: - Step1- WHEN Row_InitialPreviousRoutingContext = 1 from SREvents table then we consider QueueKey from DimQueue table coming from Commercial NextDay Datamart within SA&DP by joining PreviousRoutingContextId in SREvents table with NativeQueueID in DimQueue table.\nStep2- The QueueKey fetched from step1 is aliased as PreviousAssignedQueueKey."
  },
  {
    "reverse_engineered_description": "Int attribute from CreatedDateTime in Cases. Extract date, remove hyphens, replace null with -1.",
    "comment": "Rewrite the logic in the description focusing on clarity: 'It extracts the date from CreatedDateTime, removing the hyphen'.",
    "final_description": "Derived attribute of datatype int based on CreatedDateTime column in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic:Step1-  It fetches the date portion from CreatedDateTime and removes hyphens from it.\nStep2-If SRCreatedDateTimeId from step1 has null values then it replaces it with -1."
  },
  {
    "reverse_engineered_description": "Int attribute from CreatedDateTime in Cases. Join using SRNumber. Calculate seconds from midnight, round to nearest 30 min, subtract 1.",
    "comment": "Please review the logic again as the current explanation lacks clarity; ensure the steps are logical and follow a clear sequence.",
    "final_description": "Derived attribute of datatype int based on CreatedDateTime  column in Cases table from DFM data processed by Cornerstone.It is joined using SRNumber from both FactSupportData and Cases table.\nLogic:Step1- It calculates the number of seconds passed since the start of the day (midnight) for a given CreatedDateTime. \n           Step2- It then rounds the value fetched from step1 up to the nearest 30-minute interval and subtracts 1 second and aliased as SRCreatedDateTimeSeconds.\n\nExample: The CreatedDateTime is 2024-03-07 15:25:30,\n                Step1 : Calculate Seconds from 12 am and the time difference is 15 h 25 min 30 sec, which equals to 55,530 seconds.\n                Step 2: Divide 55,530 sec by 1800 (seconds in 30 minutes), resulting in 30.85 and round off which would be 31 mins.\n                Step 3: Multiply 31 min (from step 2) by 1800 to get Seconds in 30-minute Increments that is 55,800 seconds.\n                 Step 4: Subtract 1 second from 55,800 seconds, resulting in 55,799 seconds end as SRCreatedDateTimeSeconds.\n"
  },
  {
    "reverse_engineered_description": "Surrogate key in UDP NRT for unique FactSREvents. Generate using SRNumber.",
    "comment": "Please outline the logic for surrogate key generation, specifying which columns are utilized.",
    "final_description": "Surrogate key generated within UDP NRT to identify unique records of FactSREvents table.It is generated using SRNumber."
  },
  {
    "reverse_engineered_description": "Decode logic on EventDateTime in DFM Events. Extract date and replace nulls with -1.",
    "comment": "Update logic by referring to the approach used for SRCreatedDateTimeId column to ensure alignment and consistency.",
    "final_description": "Derived by applying decode logic on EventDateTime column in DFM Events data processed by Cornerstone.\nLogic: Step1- It extracts the date portion of EventDateTime.\nStep2- If SRModifiedTimeId from step1 has null values then it's replaced with -1."
  },
  {
    "reverse_engineered_description": "Decode logic on StateAnnotation and EventDateTime in Cases. Extract date when StateAnnotation matches, replace nulls with -1.",
    "comment": "Apply the update by using the SRCreatedDateTimeId column logic to maintain consistency throughout.",
    "final_description": "Derived by applying decode logic on StateAnnotation and EventDateTime columns in Cases table coming from DFM Events data processed by Cornerstone source.\nLogic:Step1 - It extracts the date portion of \"EventDateTime\" WHEN \"StateAnnotation\"= ('identifying the issue', 'identifying issue', 'scope').\nStep2 - If step 1 fetches null values then ut replaced with -1"
  },
  {
    "reverse_engineered_description": "Decode IncidentType and CaseType in Cases. Conditional checks return SRType or 'Unknown'.",
    "comment": "Organize and write out the logic in well-defined steps to facilitate a clear understanding.",
    "final_description": "Derived by applying decode logic on IncidentType and CaseType columns in Cases table coming from DFM Events data processed by Cornerstone having string values.\nLogic :\nStep 1 : It checks if a certain condition involving IncidentType column in FactSRSupportData table coming from Commercial NRT Datamart within SA&DP is true. \nStep 2: If Step 1 is true, then it checks the value of SRType  column in Cases table coming from DFM Events data processed by Cornerstone and assigns specific values based on different scenarios. \nStep 3: If the initial condition from Step 1 is false, it returns the result as 'Unknown'."
  }
]